1.  Initialize the open list
2.  Initialize the closed list
    put the starting node on the open
    list (you can leave its f at zero)

3.  while the open list is not empty
    a) find the node with the least f on
       the open list, call it "q"

    b) pop q off the open list

    c) generate q's 8 successors and set their
       parents to q

    d) for each successor
        i) if successor is the goal, stop search
          successor.g = q.g + distance between
                              successor and q
          successor.h = distance from goal to
          successor (This can be done using many
          ways, we will discuss three heuristics-
          Manhattan, Diagonal and Euclidean
          Heuristics)

          successor.f = successor.g + successor.h

        ii) if a node with the same position as
            successor is in the OPEN list which has a
           lower f than successor, skip this successor

        iii) if a node with the same position as
            successor  is in the CLOSED list which has
            a lower f than successor, skip this successor
            otherwise, add  the node to the open list
     end (for loop)

    e) push q on the closed list
    end (while loop)



    From Josh Hug Slides

    Required structures: Priority Queue, Best holds best known
    distances and parents. (Use linked list?)

    Start by adding the source to the fringe. Initialize best

    Dequeue the closest vertex from the fringe, which we call v
        If v is equal to the goal, we're done
        for each edge v -> w, relax that edge where relax means
            if d(s,v) + ed(v,w) is less than d(s,w) in best:
                update best so that d(s,w) = d(s,v) + ed(v,w)
                add w to the fringe with a priority equal to
                    d(s,v) + ed(v,w) + h(w)

    Euclidiean h = sqrt ( (current_cell.x – goal.x)2 +
                (current_cell.y – goal.y)2 )


    function reconstruct_path(cameFrom, current)
        total_path := {current}
        while current in cameFrom.Keys:
            current := cameFrom[current]
            total_path.append(current)
        return total_path

    function A_Star(start, goal)
        // The set of nodes already evaluated
        closedSet := {}

        // The set of currently discovered nodes that are not evaluated yet.
        // Initially, only the start node is known.
        openSet := {start}

        // For each node, which node it can most efficiently be reached from.
        // If a node can be reached from many nodes, cameFrom will eventually contain the
        // most efficient previous step.
        cameFrom := an empty map

        // For each node, the cost of getting from the start node to that node.
        gScore := map with default value of Infinity

        // The cost of going from start to start is zero.
        gScore[start] := 0

        // For each node, the total cost of getting from the start node to the goal
        // by passing by that node. That value is partly known, partly heuristic.
        fScore := map with default value of Infinity

        // For the first node, that value is completely heuristic.
        fScore[start] := heuristic_cost_estimate(start, goal)

        while openSet is not empty
            current := the node in openSet having the lowest fScore[] value
            if current = goal
                return reconstruct_path(cameFrom, current)

            openSet.Remove(current)
            closedSet.Add(current)

            for each neighbor of current
                if neighbor in closedSet
                    continue		// Ignore the neighbor which is already evaluated.

                // The distance from start to a neighbor
                tentative_gScore := gScore[current] + dist_between(current, neighbor)

                if neighbor not in openSet	// Discover a new node
                    openSet.Add(neighbor)
                else if tentative_gScore >= gScore[neighbor]
                    continue		// This is not a better path.

                // This path is the best until now. Record it!
                cameFrom[neighbor] := current
                gScore[neighbor] := tentative_gScore
                fScore[neighbor] := gScore[neighbor] + heuristic_cost_estimate(neighbor, goal)


KD Tree
function kdtree (list of points pointList, int depth)
{
    // Select axis based on depth so that axis cycles through all valid values
    var int axis := depth mod k;

    // Sort point list and choose median as pivot element
    select median by axis from pointList;

    // Create node and construct subtree
    node.location := median;
    node.leftChild := kdtree(points in pointList before median, depth+1);
    node.rightChild := kdtree(points in pointList after median, depth+1);
    return node;
}

Since the hyperplanes are all axis-aligned this
is implemented as a simple comparison to see
whether the distance between the splitting
coordinate of the search point and current node
is lesser than the distance (overall coordinates
) from the search point to the current best.